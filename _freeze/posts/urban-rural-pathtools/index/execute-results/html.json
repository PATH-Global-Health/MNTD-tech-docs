{
  "hash": "52010d01d3198c3c6628ebcd338cafc0",
  "result": {
    "markdown": "---\ntitle: \"Defining urban areas based on population rasters\"\nauthor: \"Hayley Thompson\"\ndate: \"12/20/2022\"\ncategories: [R, raster, urbanization]\nimage: \"image.jpg\"\ntoc: true\nformat:\n  html:\n    code-fold: false\n    code-tools: true\nexecute:\n  warning: false\n  message: false\n---\n\n\n## Installing the `PATHtools` package\n\nThis process uses an R package developed by PATH. This package is hosted on Github, so we have to use the `devtools` package to install it (you may need to install this package first).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"devtools\")\ndevtools::install_github(\"PATH-Global-Health/PATHtools\")\n```\n:::\n\n\nThe primary function in this package that we will use is [`define_urban()`](https://path-global-health.github.io/PATHtools/reference/define_urban.html), which defines rural and urban areas based on population density.\n\nThe function requires a population density raster which is a gridded population surface, representing population distribution. We will download this from the [`GRID3`](https://grid3.org/) data repository.\n\n## Downloading GRID3 population rasters\n\nWe will use Senegal as an example - the download links for other countries with GRID3 population data avaliable can be found in the code block below for reference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  Sierra Leone: https://wopr.worldpop.org/download/473\n#  South Sudan: https://wopr.worldpop.org/download/344\n#  Mozambique: https://wopr.worldpop.org/download/237\n#  DRC - Kinshasa, Kongo-Central, Kwango, Kwilu, and Mai-Ndombe provinces: https://wopr.worldpop.org/download/113\n#  DRC - Haut-Katanga, Haut-Lomami, Ituri, Kasaï, Kasaï Oriental, Lomami and Sud-Kivu provinces: https://wopr.worldpop.org/download/488\n#  Niger: https://wopr.worldpop.org/download/511\n#  Burkina Faso: https://wopr.worldpop.org/download/515\n#  Nigeria: https://wopr.worldpop.org/download/495\n#  Zambia: https://wopr.worldpop.org/download/25\n```\n:::\n\n\nFirst we load some useful packages for working with rasters and shapefiles, then we will download the populaiton raster file for Senegal. The GRID3 population raster is at a resolution of 100m so we need to use the `aggregate()` function from the `terra` package to combine grid cells to a spatial resolution of 1km grid cells for input into the `define_urban()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(raster)        # Raster package\nlibrary(terra)         # Terra package\nlibrary(exactextractr) # exactextractr package\nlibrary(sf)            # Shapefile package\nlibrary(CHWplacement)  # CHWplacement pakacge\nlibrary(tidyverse)     # Tidyverse \nlibrary(tidyterra)     # Tidyverse methods for terra objects\nlibrary(ggforce)       # ggforce package for facet zooming \nlibrary(PATHtools)     # PATHtools package for retriving shapefiles\nlibrary(fs)            # file system package\n\n# Load reference shapefile\nshp <- PATHtools::load_shapefile(country = \"Senegal\", admin_level = 1)\n\n# Grid3 raster URL \nurl <- \"https://wopr.worldpop.org/download/502\" # url for Senegal raster\n\n# Create a temporary folder for downloaded raster\ndest <- tempdir()\n\n# file name \nfile_name <- fs::path(dest, \"grid3-pop-raster.tif.gz\")\n\n# download and unzip the raster file \nutils::download.file(url = url, destfile = file_name, mode = \"wb\", quiet = TRUE)\nR.utils::gunzip(file_name)\n\n# load raster into R session\npopulation_100m <- terra::rast(fs::path(dest, \"grid3-pop-raster.tif\")) \n\n# aggregate population raster from 100m grid cell resolution to 1km grid cell resolution \npopulation_1km <- terra::aggregate(population_100m, fact=10, na.rm=TRUE, fun = \"sum\")\n\n# plot population per km \nggplot() +\n  geom_spatraster(data = population_1km) +\n  scale_fill_whitebox_c(palette = \"deep\", direction = -1) +\n  theme_grey() +\n  labs(title = \"GRID3 population per 1km Senegal 2020\", fill=\" \") +\n  facet_zoom(xlim=c(-17,-17.6), ylim=c(14.5,15), horizontal = TRUE, shrink=TRUE, zoom.size =0.8) +\n  theme(axis.text = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=1056}\n:::\n:::\n\n\nThe resulting plot displays the populated areas of Senegal with those areas in yellow representing the most densely populated areas with the panel highlighting Dakar - the capital city of Senegal.\n\nIn this example I created a temporary folder (using the `tempdir()`) and saved it's \"path\" into an object called `dest`. This is where we will download rasters. You can swap `tempdir()` with a file path to a location on your computer. Or directly read in a raster if it is already avaliable on your computer.\n\n## Classification of urban and rural areas\n\n::: column-margin\n![**Contigious grid cells.** The grid displays a central coloured cell surrounded by 8 other cells numbered 1 through 8. **four-point contiguity** would select grid cells 2,4,6 and 8 as contigious to the central cell. **eight-point contiguity** would select all grid cells 1 through 8 as contigious, as this definition also allows grid cells that are linked on the diagonal.](contig.jpg)\n:::\n\nThe next step in this work is to use the `define_urban()` function from the `PATHtools` pacakge to define urban areas. This is done using 1km² grid cells, classified according to their **population density**, **population size** and **contiguity** (neighbouring cells).\n\nThis function requires 3 inputs:\n\n1.  **population_raster**: An input raster containing people per pixel. Default inputs assume input resolution to be approximately 1km² resolution\n\n2.  **rururb_cutoff**: indicates the minimum population per pixel to be eligible for urban classification\n\n3.  **min_urbsize**: indicates the minimum population in the total area of contiguous selected pixels to be considered as urban\n\nThe identification of urban areas then occurs in two steps, first all cells with a population density of over `runurb_cutoff` are selected and then groups of contigious cells are identified using eight-point contiguity, in other words, including diagonals (see margin figure). Contigious cells are grouped together and each group with a collective population size of over `min_urbsize` are defined as urban.\n\nFor this example we use a population density threshold of 300 people per square km (`rururb_cutoff`) and a minimum population size (`min_urbsize`) of 10,000 people.\n\nThese values were selected based on the smallest population density threshold used to define an urban area from the Level 1 definitions in [`Eurostat: Applying the Degree of Urbanisation — A methodological manual to define cities, towns and rural areas for international comparisons — 2021 edition`](https://ec.europa.eu/eurostat/en/web/products-manuals-and-guidelines/-/ks-02-20-499) and the value of 10,000 came from the national definition of an urban area as listed in the [`UN Demographic Year Book 2021`](https://unstats.un.org/unsd/demographic-social/products/dyb/documents/dyb2021/Notes06.pdf).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# run function to define urban clusters\n\n# this first function call we set mask == FALSE to output a raster with only urban cells and their associated population values\nur_population <- define_urban(population_1km, min_urbsize = 10000, rururb_cutoff = 300, mask = FALSE)\n\n# this second function call we set mask == TRUE to output a raster that defines each pixel as urban (1) or rural (0)\nur_categories <- define_urban(population_1km, min_urbsize = 10000, rururb_cutoff = 300, mask = TRUE) \ncls <- data.frame(id=c(1, 0), urban_rural=c(\"urban\", \"rural\"))\nlevels(ur_categories) <- cls\n```\n:::\n\n\nThe function outputs a new raster which we have saved as an object in our R session called `ur_population` and `ur_categories`. This first is a raster is similar to `population_raster` input but all non-urban pixels are masked (i.e. NA). And the second a raster that classifies populated pixels as either urban or rural.\n\n\n::: {.cell .caption-margin layout-ncol=\"2\"}\n::: {.cell-output-display}\n![define_urban() function outputs](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![ ](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\nFor performing this analysis for another country users can use the threshold values from the Eurostat manual, or if a national threshold is provided the user can select these. The Eurostat manual uses two definitions of urban at a level 1 classification.\n\n1.  **Urban centre** (high density cluster) - a cluster of contiguous grid cells of 1km² (using four-point contiguity, in other words, excluding diagonals. *To perform 4 point contiguity in the `define_urban()` function set `directions = 4` in the function call*) with a population density of at least 1,500 inhabitants per km² and collectively a minimum population of 50,000 inhabitants before gap-filling.\n\n2.  **Urban cluster** (moderate-density cluster) --- a cluster of contiguous grid cells of 1 km² (using eight-point contiguity, in other words, including diagonals) with a population density of at least 300 inhabitants per km² and a minimum population of 5,000 inhabitants.\n\n\n## Calculating the urban proportion of the population in a spatial area defined by an input shape file\n\nTo calcualte the proportion of the population in a spatial region that live in urban or rural areas we first need a shape file with defined boundaries e.g. administrative units or health facility catchment areas.\n\nFor this example we will use a shapefile of the 14 regions of Senegal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# crop the raster to the shape file outline of senegal to ensure extents match \nur_population <- crop(ur_population, extent(shp))\nur_population <- mask(ur_population, shp)\n\n# for ID-ing regions\nsf_tibble <- tibble::as_tibble(sf::st_drop_geometry(shp))\n\n# extract the full GRID3 population to admin-1 units \nadm1_pop <-\n    exactextractr::exact_extract(population_1km, shp, 'sum', progress = FALSE) %>% \n    dplyr::bind_cols(sf_tibble) %>% \n    dplyr::select(ADM1, total_pop = ...1)\n  \n# extract urban population to admin-1 units  \nadm1_urb_pop <- \n    exactextractr::exact_extract(ur_population, shp, 'sum', progress = FALSE) %>% \n    dplyr::bind_cols(sf_tibble) %>% \n    dplyr::select(ADM1, urban_pop = ...1)\n\n# join dataframes together and calculate proportion of the population in urban areas per admin-1 units \nurb_pop_prop <- \n  left_join(adm1_pop, adm1_urb_pop) %>% \n  mutate(prop_ur = urban_pop / total_pop) %>% \n  mutate(prop_ur = case_when(is.na(prop_ur) ~ 0, TRUE ~ prop_ur))\n\n# plot the proportion of the population living in urban areas by admin-1 units \nshp_pop <- \n  shp %>% \n  left_join(urb_pop_prop) \n\nggplot(shp_pop) +\n  geom_sf(aes(fill=prop_ur*100), col=NA) +\n  scale_fill_whitebox_c(palette= \"deep\") +\n  theme_gray(10) +\n  theme(axis.text = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank(),\n        legend.position=\"bottom\", \n        legend.key.width = unit(2, 'cm')) +\n  labs(fill=\"%\", title=\"Proprtion of the population living in urban areas 2020\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=4200}\n:::\n:::\n\n\n## Classifying point locations based on urban rural pixel classifications\n\nIf geo-location or point data is avaliable, for example the co-ordinates of health facilities, hospitals, schools, pharmacies etc, then we can use the `ur_categories` raster output to classify these services and the communities they serve.\n\nHere I create some example coordinates but users should upload their own coordinates of interest here. In this example we include a 2.5km buffer region around each point to account for potential heterogeneity that might be missed from taking just the point-level extraction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# example coordinates \npoints <- data.frame(name = c(\"a\", \"b\", \"c\", \"d\"), \n                     latitude = c(14.72810, 15.01430, 15.99420, 12.67370), \n                     longitude = c(-17.45910, -12.50030, -15.32010, -16.09250))\n\n# transform to a spatial object \npoints   <- sf::st_as_sf(points,                                # first argument = data frame with coordinates\n                          coords = c(\"longitude\", \"latitude\"),  # name of columns, in quotation marks\n                          crs = 4326)                           # coordinate reference system to make sense of the numbers\n\n# include a 2.5km buffer region around point location   \npoints_w_buffer <- terra::vect(points) %>% terra::buffer(width=2500) \n```\n:::\n\n\nBecause we include a buffer region we will then take the mode of the extracted cell values for each of our locations. The following function calculates and returns the mode of the categorical extraction variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_mode <- function(x) {\n  uniqx <- unique(na.omit(x))\n  uniqx[which.max(tabulate(match(x, uniqx)))]\n}\n```\n:::\n\n\nNow we can run the extraction and examine the resulting classification.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# crop the raster to the shape file outline of senegal to ensure extents match \nur_categories <- crop(ur_categories, extent(shp))\nur_categories <- mask(ur_categories, shp)\n\n# extraction\npoints_classification <- \n  terra::extract(ur_categories, points_w_buffer) %>%\n  dplyr::group_by(ID) %>%\n  dplyr::summarise(dplyr::across(dplyr::everything(), list)) %>%\n  tidyr::unnest(cols = c(urban_rural)) %>%\n  dplyr::group_by(ID) %>%\n  dplyr::summarize(classification = calculate_mode(urban_rural)) \n\n# as a spatial object\npoints_classification_sf <- bind_cols(points, points_classification)\n\n# plot \nggplot() +\n  geom_spatraster(data = ur_categories) +\n  geom_sf(data = points_classification_sf, mapping=aes(col=classification), shape = 19,\n          fill=NA, size=1)+\n  theme_grey(12) +\n  labs(title = \"\", fill=\" \", col=\" \") +\n  scale_color_manual(values=c(\"#b01f35\", \"#C6EBC5\"),\n                     labels=c(\"urban\", \"rural\"), breaks=c(\"urban\", \"rural\")) +\n  scale_fill_manual(values=c(\"#FA7070\", \"#4f7942\"), \n                    labels=c(\"urban\", \"rural\"), breaks=c(\"urban\", \"rural\")) +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid = element_blank(),\n        legend.position=\"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=4200}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}