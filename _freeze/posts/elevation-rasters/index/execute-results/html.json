{
  "hash": "20f8e75aac3a724c1c329d9cf7fa21ee",
  "result": {
    "markdown": "---\ntitle: \"Downloading elevation data in R\"\nauthor: \"Justin Millar\"\ndate: \"7/13/2022\"\ncategories: [remote sensing, R, raster]\nimage: \"image.jpg\"\ntoc: true\nformat:\n  html:\n    code-fold: false\n    code-tools: true\nexecute:\n  warning: false\n  message: false\n---\n\n## Installing the `whatarelief` package\n\nWe will be using a relatively new R package called [`whatarelief`](https://github.com/mdsumner/whatarelief). This package is hosted on Github, but is not currently on CRAN so we have to use the `devtools` package to install (you may need to install this package first).\n\n\n\nThe primary function in this package is called `elevation()`, which downloads a elevation raster directly into our R session. This raster can be automatically formatted for specific locations using a reference extent, shapefile, or other raster file.\n\nThe [package documentation](https://mdsumner.github.io/whatarelief/) provide all the information you'll need to get started, including how to [select difference elevation sources](https://mdsumner.github.io/whatarelief/articles/elevation-sources.html). It's worth looking through the documentation, as there are some quarks.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(whatarelief)\nimage(im <- elevation())\n```\n\n::: {.cell-output-stdout}\n```\n[1] \"/vsicurl/https://public.services.aad.gov.au/datasets/science/GEBCO_2019_GEOTIFF/GEBCO_2019.tif\"\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nimage(t(im[nrow(im):1, ]))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\nThe next section will demonstrate a brief example for getting elevation data from Zambia\n\n## Example: Elevation raster for Zambia\n\nTo get started, let's load some useful packages for working with rasters and shapefiles, then we will download a shapefile for Zambia.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(raster)   # Raster package\nlibrary(sf)       # Shapefile package\nlibrary(PATHtoolsZambia)  # PATH data for Zambia\n\n# Load reference shapefile\nshp <- retrieve(\"province-shp\")\n\n# Load reference raster\nrst <- retrieve(\"grid3-pop-rescaled\")\n\n# Visualize\nplot(rst, col = viridis::plasma(100))\nplot(st_geometry(shp), add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\nTo use a reference raster to select an area for interest, all we need to do is include the raster object in the `elevation()` functions.\n\n::: {.cell}\n\n```{.r .cell-code}\nzm_elv1 <- elevation(rst)\n```\n\n::: {.cell-output-stdout}\n```\n[1] \"/vsicurl/https://public.services.aad.gov.au/datasets/science/GEBCO_2019_GEOTIFF/GEBCO_2019.tif\"\n```\n:::\n\n```{.r .cell-code}\nplot(zm_elv1)\nplot(st_geometry(shp), add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nConveniently, this elevation raster is at the same resolution and alignment as our reference.\n\n::: {.cell}\n\n```{.r .cell-code}\ncompareRaster(rst, zm_elv1)\n```\n\n::: {.cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nstack(rst, zm_elv1)\n```\n\n::: {.cell-output-stdout}\n```\nclass      : RasterStack \ndimensions : 1177, 1406, 1654862, 2  (nrow, ncol, ncell, nlayers)\nresolution : 0.008333333, 0.008333333  (x, y)\nextent     : 21.99542, 33.71208, -18.07958, -8.27125  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      : grid3_1km_rescaled.1, grid3_1km_rescaled.2 \nmin values :             1.042396,           118.241821 \nmax values :            30135.733,             2726.069 \n```\n:::\n:::\n\nTo test this functionality, let's aggregate our reference raster and get a new elevation raster.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aggregate by a factor of 5\nrst_agg <- aggregate(rst, 5, fun = \"sum\")\nplot(rst_agg, col = viridis::plasma(100))\nplot(st_geometry(shp), add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Pull aggregated version of elevation \nzm_elv2 <- elevation(rst_agg)\n```\n\n::: {.cell-output-stdout}\n```\n[1] \"/vsicurl/https://public.services.aad.gov.au/datasets/science/GEBCO_2019_GEOTIFF/GEBCO_2019.tif\"\n```\n:::\n\n```{.r .cell-code}\nplot(zm_elv2)\nplot(st_geometry(shp), add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Compare\ncompareRaster(rst_agg, zm_elv2)\n```\n\n::: {.cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nstack(rst_agg, zm_elv2)\n```\n\n::: {.cell-output-stdout}\n```\nclass      : RasterStack \ndimensions : 236, 282, 66552, 2  (nrow, ncol, ncell, nlayers)\nresolution : 0.04166667, 0.04166667  (x, y)\nextent     : 21.99542, 33.74542, -18.10458, -8.27125  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      : grid3_1km_rescaled.1, grid3_1km_rescaled.2 \nmin values :             1.065404,           131.133560 \nmax values :           226794.442,             2450.497 \n```\n:::\n\n```{.r .cell-code}\ntry(compareRaster(zm_elv1, zm_elv2))\n```\n\n::: {.cell-output-stdout}\n```\nError in compareRaster(zm_elv1, zm_elv2) : different extent\n```\n:::\n:::\n\nIt is also possible to download rasters using just the extent as a numeric vector, which means it is also possible to use a shapefile. However, you will also have to provide the projection and potential other spatial information, which may be more difficult than just using a reference raster.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}