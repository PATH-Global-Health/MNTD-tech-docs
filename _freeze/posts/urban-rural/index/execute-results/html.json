{
  "hash": "e51ce2d4c625cbbc2cb5670ea496e650",
  "result": {
    "markdown": "---\ntitle: \"Defining urban areas based on population density rasters\"\nauthor: \"Hayley Thompson\"\ndate: \"12/20/2022\"\ncategories: [R, raster, urbanization]\nimage: \"image.jpg\"\ntoc: true\nformat:\n  html:\n    code-fold: false\n    code-tools: true\nexecute:\n  warning: false\n  message: false\n---\n\n\n## Installing the `CHWplacement` package\n\nThis process uses an R package developed by Clara Champagne at SwissTPH called [`CHWplacement`](https://swisstph.github.io/CHWplacement), associated with the following publication: [`Improving access to care and community health in Haiti with optimized community health worker placement`](https://journals.plos.org/globalpublichealth/article?id=10.1371/journal.pgph.0000167), *Champagne C., Rajkumar A. S. , Auxila P., Perrone G., Plötz M., Young A., Bazaz Jazayeri S., Napier H., Le Menach A., Battle K., Cameron E., Alfred J.P., Deslouches Y.G., Pothin E., Plos Global Public Health 2022.*\n\nThis package is hosted on Github, so we have to use the `devtools` package to install it (you may need to install this package first).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"SwissTPH/CHWplacement\")  \n```\n:::\n\n\nThe primary function in this package that we will use is [`DefineUrban()`](https://swisstph.github.io/CHWplacement/reference/DefineUrban.html), which defines rural and urban areas based on population density.\n\nThe function requires a population density raster which is a gridded population surface, representing population distribution. We will download this from the [`GRID3`](https://grid3.org/) data repository.\n\n## Downloading GRID3 population rasters\n\nWe will use Senegal as an example - the download links for other countries with GRID3 population data avaliable are commented out in the code block below for reference.\n\nFirst we load some useful packages for working with rasters and shapefiles, then we will download the populaiton raster file for Senegal. The GRID3 population raster is at a resolution of 100m so we need to use the `aggregate()` function from the `terra` package to combine grid cells to a spatial resolution of 1km grid cells for input into the `DefineUrban()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(raster)        # Raster package\nlibrary(terra)         # Terra package\nlibrary(exactextractr) # exactextractr package\nlibrary(sf)            # Shapefile package\nlibrary(CHWplacement)  # CHWplacement pakacge\nlibrary(tidyverse)     # Tidyverse \nlibrary(tidyterra)     # Tidyverse methods for terra objects\nlibrary(ggforce)       # ggforce package for facet zooming \nlibrary(PATHtools)     # PATHtools package for retriving shapefiles\nlibrary(fs)            # file system package\n\n# Load reference shapefile\nshp <- PATHtools::load_shapefile(country = \"Senegal\", admin_level = 1)\n\n# Grid3 raster URL \nurl <- \"https://wopr.worldpop.org/download/502\" # url for Senegal raster\n\n#  Sierra Leone: https://wopr.worldpop.org/download/473\n#  South Sudan: https://wopr.worldpop.org/download/344\n#  Mozambique: https://wopr.worldpop.org/download/237\n#  DRC - Kinshasa, Kongo-Central, Kwango, Kwilu, and Mai-Ndombe provinces: https://wopr.worldpop.org/download/113\n#  DRC - Haut-Katanga, Haut-Lomami, Ituri, Kasaï, Kasaï Oriental, Lomami and Sud-Kivu provinces: https://wopr.worldpop.org/download/488\n#  Niger: https://wopr.worldpop.org/download/511\n#  Burkina Faso: https://wopr.worldpop.org/download/515\n#  Nigeria: https://wopr.worldpop.org/download/495\n#  Zambia: https://wopr.worldpop.org/download/25\n\n# Create a temporary folder for downloaded raster\ndest <- tempdir()\n\n# file name \nfile_name <- fs::path(dest, \"grid3-pop-raster.tif.gz\")\n\n# download and unzip the raster file \nutils::download.file(url = url, destfile = file_name, mode = \"wb\", quiet = TRUE)\nR.utils::gunzip(file_name)\n\n# load raster into R session\npopulation_100m <- terra::rast(fs::path(dest, \"grid3-pop-raster.tif\")) \n\n# aggregate population raster from 100m grid cell resolution to 1km grid cell resolution == density per km^2\npopulation_1km <- terra::aggregate(population_100m, fact=10, na.rm=TRUE, fun = \"sum\")\n\n# plot population density per km \nggplot() +\n  geom_spatraster(data = population_1km) +\n  scale_fill_whitebox_c(palette = \"deep\", direction = -1) +\n  theme_grey() +\n  labs(title = \"GRID3 population per 1km Senegal 2020\", fill=\" \") +\n  # geom_sf(data=sen_shp, col=\"red\", fill=NA) +\n  facet_zoom(xlim=c(-17,-17.6), ylim=c(14.5,15), horizontal = TRUE, shrink=TRUE, zoom.size =0.8) +\n  theme(axis.text = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=1056}\n:::\n:::\n\n\nThe resulting plot displays the populated areas of Senegal with those areas in yellow representing the most densley populated areas with the zoomed in panel highlighting Dakar.\n\nIn this example I created a temporary folder (using the `tempdir()`) and saved it's \"path\" into an object called `dest`. This is where we will download rasters. You can swap `tempdir()` with a file path to a location on your computer. Or directly read in a raster if it is already avaliable on your computer.\n\n## Classification of urban and rural areas\n\n::: column-margin\n![**Contigious grid cells.** The grid displays a central coloured cell surrounded by 8 other cells numbered 1 through 8. **four-point contiguity** would select grid cells 2,4,6 and 8 as contigious to the central cell. **eight-point contiguity** would select all grid cells 1 through 8 as contigious, as this definition also allows grid cells that are linked on the diagonal.](contig.jpg)\n:::\n\nThe next step in this work is to use the `CHWplacement` pacakge to define urban areas. This is done using 1km² grid cells, classified according to their **population density**, **population size** and **contiguity** (neighbouring cells).\n\nWe will use the `DefineUrban()` fucntion. This function requires 3 inputs:\n\n1.  **population.raster**: raster map containing population densities per 1km grid cells\n\n2.  **rururb_cutoff**: indicates the minimum population density for each pixel considered as urban\n\n3.  **min_urbsize**: indicates the minimum population in the total area of contiguous selected pixels to be considered as urban\n\nThe identification of urban areas then occurs in two steps, first all cells with a population density of over `runurb_cutoff` are selected and then groups of contigious cells are identified using eight-point contiguity, in other words, including diagonals. Contigious cells are grouped together and each group with a collective population size of over `min_urbsize` are defined as urban.\n\nFor this example we use a population density threshold of 300 people per square km (`rururb_cutoff`) and a minimum population size (`min_urbsize`) of 10,000 people.\n\nThese values were selected based on the smallest population density threshold used to define an urban area from the Level 1 definitions in [`Eurostat: Applying the Degree of Urbanisation — A methodological manual to define cities, towns and rural areas for international comparisons — 2021 edition`](https://ec.europa.eu/eurostat/en/web/products-manuals-and-guidelines/-/ks-02-20-499) and the value of 10,000 came from the national definition of an urban area as listed in the [`UN Demographic Year Book 2021`](https://unstats.un.org/unsd/demographic-social/products/dyb/documents/dyb2021/Notes06.pdf).\n\nFor performing this analysis for another country users can use the threshold values from the Eurostat manual, or if a national threshold is provided the user can select these. The manual uses two definitions of urban at a level 1 classification.\n\n1.  **Urban centre** (high density cluster) - a cluster of contiguous grid cells of 1km² (using four-point contiguity, in other words, excluding diagonals. *As the CHWpackage function uses eight-point contiguity the function will have to be editied by the user to perform this.*) with a population density of at least 1,500 inhabitants per km² and collectively a minimum population of 50,000 inhabitants before gap-filling.\n\n2.  **Urban cluster** (moderate-density cluster) --- a cluster of contiguous grid cells of 1 km² (using eight-point contiguity, in other words, including diagonals) with a population density of at least 300 inhabitants per km² and a minimum population of 5,000 inhabitants.\n\nThe following code shows how we can take the population raster input and the thresholds we have defined to produce an output raster that defines grid cells as urban or rural.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first need to convert spatial raster to raster layer to work with the DefineUrban function \npopulation_1km_r <- population_1km %>% raster::raster()\n\n# run function to define urban clusters\nur <- DefineUrban(population_1km_r, min_urbsize = 10000, rururb_cutoff = 300)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Proportion of the population in urban areas is 54.14%\"\n```\n:::\n:::\n\n\nThe function outputs a new raster which we have saved as an object in our R session called `ur`. This raster is similar to population.raster input but all non-urban pixels are masked (i.e. NA). The function call also outputs the proportion of the total population that live in urban areas. We can take this a step further and examine the rates of urbanisation at smaller spatial scales.\n\n## Calculating the proportion of the population in a spatial area defined by an input shape file\n\nTo calcualte the proportion of the population in a spatial region that live in urban or rural areas we first need a shape file with defined boundaries e.g. administrative units or health facility catchment areas.\n\nFor this example we will use a shapefile of the 14 regions of Senegal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# for ID-ing regions\nsf_tibble <- tibble::as_tibble(sf::st_drop_geometry(shp))\n\n# extract the full GRID3 population to regions \nregional_pop <-\n    exactextractr::exact_extract(population_1km, shp, 'sum', progress = FALSE) %>% \n    dplyr::bind_cols(sf_tibble) %>% \n    dplyr::select(region = ADM1, total_pop = ...1)\n  \n# extract urban population to regions \nregional_urb_pop <- \n    exactextractr::exact_extract(ur, shp, 'sum', progress = FALSE) %>% \n    dplyr::bind_cols(sf_tibble) %>% \n    dplyr::select(region = ADM1, urban_pop = ...1)\n\n# join dataframes together and calculate proportion of the population in urban areas per health district\nurb_pop_prop <- \n  left_join(regional_pop, regional_urb_pop) %>% \n  mutate(prop_ur = urban_pop / total_pop) %>% \n  mutate(prop_ur = case_when(is.na(prop_ur) ~ 0, TRUE ~ prop_ur))\n\n# plot the proportion of the population living in urban areas by region\nshp_pop <- \n  shp %>% \n  janitor::clean_names() %>% \n  rename(region = adm1) %>% \n  left_join(urb_pop_prop) \n\nggplot(shp_pop) +\n  geom_sf(aes(fill=prop_ur), col=NA) +\n  scale_fill_whitebox_c(palette= \"deep\") +\n  theme_gray() +\n  theme(axis.text = element_blank(), \n        axis.ticks = element_blank(), \n        panel.grid = element_blank()) +\n  labs(fill=\" \", title=\"Proprtion of the population living in urban areas 2020\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Creating an new raster that defines each grid cell as urban or rural\n\nWe can then transform the raster output from the `DefineUrban()` function so that all NA cells are reclassified as \"rural\" and those with population values are classified as \"urban\". The resulting raster highlighting urban areas defined by population density and size thresholds is shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# transform to spatraster format  \nur_raw <- terra::rast(ur)\n\n# reclassification of grid cells \nur_class <- app(ur_raw, fun=function(x){ x[x > 1] <- 1; return(x)} )\nur_class <- subst(ur_class, NA, 2) \ncls <- data.frame(id=c(1, 2), urban_rural=c(\"urban\", \"rural\"))\nlevels(ur_class) <- cls\n\n# crop the raster to the shape file outline of senegal to remove extra pixels that have been # classified as rural but are empty pixels outside country boundary\nur_class <- crop(ur_class, extent(shp))\nur_class <- mask(ur_class, shp)\n\n# plot the resulting output \nggplot() +\n  geom_spatraster(data = ur_class) +\n  theme_grey(12) +\n  labs(title = \" \", fill=\" \", col=\" \") +\n  scale_fill_manual(values=c(\"#ed968c\", \"#4f7942\"), \n                    labels=c(\"urban\", \"rural\"), breaks=c(\"urban\", \"rural\")) +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid = element_blank(),\n        legend.position=\"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nIf geo-location data is then avaliable, for example the co-ordinates of health facilities, hospitals, schools, pharmacies etc, then we can use this raster to classify these facilties and the communities they serve.\n\nHere I create some example coordinates but users should upload their own coordinates of interest here. In this example we include a 2.5km buffer region around each point to account for potential heterogeneity that might be missed from taking just the point-level extraction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# example coordinates \npoints <- data.frame(name = c(\"a\", \"b\", \"c\", \"d\"), \n                     latitude = c(14.72810, 15.01430, 15.99420, 12.67370), \n                     longitude = c(-17.45910, -12.50030, -15.32010, -16.09250))\n\n# transform to a spatial object \npoints   <- sf::st_as_sf(points,                               # first argument = data frame with coordinates\n                          coords = c(\"longitude\", \"latitude\"),  # name of columns, in quotation marks\n                          crs = 4326)                           # coordinate reference system to make sense of the numbers\n\n# include a 2.5km buffer region around point location   \npoints_w_buffer <- terra::vect(points) %>% terra::buffer(width=2500) \n```\n:::\n\n\nBecause we include a buffer region we will then take the mode of the extracted cell values for each of our locations. The following function calculates and returns the mode of the categorical extraction variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_mode <- function(x) {\n  uniqx <- unique(na.omit(x))\n  uniqx[which.max(tabulate(match(x, uniqx)))]\n}\n```\n:::\n\n\nNow we can run the extraction and examine the resulting classification.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extraction\npoints_classification <- \n  terra::extract(ur_class, points_w_buffer) %>%\n  dplyr::group_by(ID) %>%\n  dplyr::summarise(dplyr::across(dplyr::everything(), list)) %>%\n  tidyr::unnest(cols = c(urban_rural)) %>%\n  dplyr::group_by(ID) %>%\n  dplyr::summarize(classification = calculate_mode(urban_rural)) \n\n# as a spatial object\npoints_classification_sf <- bind_cols(points, points_classification)\n\n# plot \nggplot() +\n  geom_spatraster(data = ur_class) +\n  geom_sf(data = points_classification_sf, mapping=aes(col=classification), shape = 19,\n          fill=NA, size=1)+\n  theme_grey(12) +\n  labs(title = \"\", fill=\" \", col=\" \") +\n  scale_color_manual(values=c(\"#b01f35\", \"#e4efe9\"),\n                     labels=c(\"urban\", \"rural\"), breaks=c(\"urban\", \"rural\")) +\n  scale_fill_manual(values=c(\"#ed968c\", \"#4f7942\"), \n                    labels=c(\"urban\", \"rural\"), breaks=c(\"urban\", \"rural\")) +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid = element_blank(),\n        legend.position=\"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=4200}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}